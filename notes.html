<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        //CLOSURES
        // When JS knows that it will need a variable later and when that variable is
        // getting destroyed by the natural flow of the execution, variable will be saved
        // as the closure variable.
        // // Closure examples

        // 1. First example var saves variable i out of the scope of the for loop
        // so, anonymous function that will use i later doesn't need to save it.
        // Loop runs and updates i to 3 and exits the loop. This is when setTimeout
        // is over with waiting and gives a first call to anyonimous function. At that
        // point i is at the value 3.

        // function f1() {
        //     for (var i = 0; i < 3; i++) {
        //         console.log(i)
        //         setTimeout(() => {
        //             console.log(i)
        //         }, 1000 * i)
        //     }
        // }

        // 2. Example: Since anonymous functino has to use variable i later, and that
        // variable is destroyed by the natural flow of the code execution, 
        // anonymous function saves variable i at that point of time in order to 
        // get to a closure when it comes time for that.

        // function f2() {
        //     for (let i = 0; i < 3; i++) {
        //         console.log(i)
        //         setTimeout(() => {
        //             console.log(i)
        //         }, 1000 * i)
        //     }
        // }
        
        // FIBONACCI RECURSIVELY
        // function naive_fib(n) {
        //     if(n === 1 || n === 2) return 1
        //     result = naive_fib(n-1) + naive_fib(n -2)
        //     return result
        // }

        // console.time("naive")
        // console.log(naive_fib(30))
        // console.timeEnd("naive")

        // // FIBONACCI MEMOISATION
        // function fib_memo(n, memo=[]) {
        //     if(n===1 || n===2) return 1
        //     if (memo[n] !== undefined) {
        //         return memo[n]
        //     }
        //     memo[n] = fib_memo(n -1, memo)  + fib_memo(n - 2, memo)
        //     result = memo[n]
        //     return result
        // }

        // console.time("memo")
        // console.log(fib_memo(30))
        // console.timeEnd("memo")

        // // FIBONACCI DIYNAMIC

        // function fib_dyn(n) {
        //     if(n === 1 || n === 2) return 1
        //     bottom_up = []
        //     bottom_up[1] = 1
        //     bottom_up[2] = 1

        //     for (let i = 3; i < n+1; i++) {
        //         bottom_up[i] = bottom_up[i-1] + bottom_up[i-2]
        //     }
        //     return bottom_up[n]
        // }

        // console.time("dynamic")
        // console.log(fib_dyn(30))
        // console.timeEnd("dynamic")

        // PROMISES
        // userLeft = false
        // userWatchingMemes = true

        // function watchTutorialPromise() {
        //     return new Promise((resolve, reject) => {
        //         if(userLeft) {
        //             reject({
        //                 name: "User Left",
        //                 message: ":("
        //             })
        //         } else if (userWatchingMemes) {
        //             reject({
        //                 name: "User watching memes.",
        //                 message: "Ahh those memes..."
        //             })
        //         } else {
        //             resolve("Thumbs up and subscribe")
        //         }
        //     })
        // }

        // watchTutorialPromise()
        //     .then((message) => {
        //         console.log(`Success ${message}`)
        //     })
        //     .catch((err) => {
        //         console.log(`${err.name} ${err.message}`)
        //     })

        // function makeRequest(location) {
        //     return new Promise((resolve, reject) => {
        //         console.log(`Making Request to ${location}`)
        //         if (location === "Google") {
        //             resolve("Google says hi")
        //         } else {
        //             reject("We can only talk to Google")
        //         }
        //     })
        // }

        // function processRequest(response) {
        //     return new Promise((resolve, reject) => {
        //         console.log("Processing response")
        //         resolve(`Extre information + ${response}`)
        //     })
        // }
        // CALLING WITH .then
        // makeRequest("Google")
        //     .then((responnse) => {
        //         console.log("Response recieved")
        //         return processRequest(responnse)
        //     })
        //     .then(processResponse => {
        //         console.log(processResponse)
        //     })
        //     .catch(err => {
        //         console.log(err)
        //     })

        // CALLING WITH ASYNC AWAIT
        // async function doWork() {
        //     try {
        //         const response = await makeRequest("f")
        //         console.log("Response recieved")
        //         const processResponse = await processRequest(response)
        //         console.log(processResponse)
        //     } catch(err) {
        //         console.log(err)
        //     }
        // }
        // doWork(

        // TRANSLATE NUMBER TO BINARY
        // n = 5
        // binaryN = n.toString(2)
        // console.log(binaryN)
        // TRANSLATE NUMBER TO BINARY - SAFELY
        // n = 5
        // binaryN = (n >>> 0).toString(2)
        // console.log(binaryN)
        // TRANSLATE NEGATIVE NUMBER TO BINARY
        // n = -5 
        // binaryN = (n >>> 0).toString(2)
        // console.log(binaryN)
        
        // BINARY SHIFTING
        // for (i = 0; i < 111; i++) { 
        //     console.log(`Index is ${i}`)
        //     console.log(i >> 1)
        //     console.log(i >>> 1)
        // }

        // LONELY INTEGER PROBLEM (https://www.hackerrank.com/challenges/lonely-integer/problem)
        // BRUTE FORCE SOLUTION

        // let arr = []
        // for (i = 0; i < 10001; i++) {
        //     arr.push(i)
        // }

        // for (i = 9999; i > -1; i--) {
        //     arr.push(i)
        // }

        // function brute(arr) {
        //     arr.forEach((element, index) => {
        //         for (i = index + 1;  i < arr.length; i++) {
        //             if(element === arr[i]) {
        //                 delete arr[i]
        //                 delete arr[index]
        //             } 
        //         }
        //     }) 
        //     arr = arr.filter(element => {
        //         return element !== undefined
        //     })
        //     console.log(arr)
        // }
        // console.time("brute")
        // brute(arr)
        // console.timeEnd("brute")

        // BIT MANIPULATION
        // let arr = [1, 2, 3, 2, 1]
        
        // function bit(arr) {
        //     arr = arr.reduce((a, b) => {
        //         return a^b
        //     })
        //     console.log(arr)
        // }
        // console.time("bit")
        // bit(arr)
        // console.timeEnd("bit")
    
        // function hash(arr) {
        //     let obj = {}
        //     for (i = 0; i < arr.length; i++) {
        //         obj[arr[i]] = 0 
        //     }
        //     for (i = 0; i < arr.length; i++) {
        //         obj[arr[i]] = obj[arr[i]] + 1 
        //     }
        //     return Object.keys(obj)[Object.values(obj).indexOf(1)]
        // }
        // console.time("hash")
        // console.log(hash(arr))
        // console.timeEnd("hash")
        //
        // CODINGAME PROBLEM
        // Create fucntion that takes array of temperatures and returns the one that is
        // closest to 0.     
        // function computeClosestToZero(ts) {
        //     // Write your code here
        //     // To debug: console.error('Debug messages...');
        //     let obj = {}
        //     if (ts.length === 0) {
        //         return 0
        //     }
        //     for (i = 0; i < ts.length; i++) {
        //         obj[Math.abs(ts[i])] = ts[i]
        //     }
        //     let absoluteResult = Math.min(...Object.keys(obj))
        //     let result = obj[absoluteResult]
        //     console.log(Object.values(obj))
        //     return result
        // }

        // console.log(computeClosestToZero([7, 5, 9, 1, 4]))
        // console.log(computeClosestToZero([-273]))
        // console.log(computeClosestToZero([5526]))
        // console.log(computeClosestToZero([-15, -7, -9, -14, -12]))
        // console.log(computeClosestToZero([-10, 10]))
        // console.log(computeClosestToZero([]))
        // console.log(computeClosestToZero([15, -7, 9, 14, 7, 12]))

    //     function minimumBribes(q) {
    //         // Write your code here
    //         let tooChaotic = ""
    //         let queueMisplacement = q.map((e, index) => {
    //             let bribed = (e-1) -index
    //             if(bribed > 2) {
    //                 tooChaotic = "Too Chaotic!"
    //             } 
    //             return bribed
    //         })
    //         let positiveQueueMisplacement = queueMisplacement.filter(e => {
    //             return e > 0
    //         })
    //         let result = positiveQueueMisplacement.reduce((acc, cur) => {
    //             return acc + cur
    //         })
    //         q.forEach((e, index) => {
    //             if(q[index + 1] < e && q[index - 1] > e) {
    //                 result++
    //             }
    //         })
    //         if(tooChaotic) {
    //             console.log("Too chaotic") 
    //         } else {
    //             console.log(result)   
    //      }
    // }
    // minimumBribes([1, 2, 5, 3, 7, 8, 6, 4])
    
            
    // THE NEW YEARS CHAOS - from n to 0 - this makes more sense. 
    // It answers the question of how many spaces number moved up or: how many bribes number GAVE
    // Read more after this implementation
    // function minimumBribes(q) {
    //     let swaps = 0;
    //     for (let i = q.length -1; i > 0; i--) {
    //         if(q[i] !== (i+1)) {
    //             if(q[i-1] === (i+1)) {
    //                 let temp = q[i-1]
    //                 q[i -1] = q[i]
    //                 q[i] = temp
    //                 swaps += 1
    //             } else if(q[i-2] === (i+1)) {
    //                 q[i-2] = q[i-1]
    //                 q[i-1] = q[i]
    //                 q[i] = (i+1)
    //                 swaps += 2
    //             } else {
    //                 console.log("Too chaotic")
    //                 return
    //             }
    //         }
    //     }
    //     console.log(swaps)
    // }

    // minimumBribes([1, 2, 5, 3, 7, 8, 6, 4])

   // THE NEW YEARS CHAOS - from 0 to n - this answers how many spaces number dropped or: How many bribes it RECIVED.
   // This is not restricted, so we first have to check if someone gave to many bribes and then count these. 
   // Ecxeeds time limit for some test cases on hacker rank.
   
//    function minimumBribes(q) {
//         let swaps = 0
//         if(q.some((element, index) => {
//             return ((element-1) - index) > 2
//         })) {
//             console.log("Too chaotic")
//             return 
//         }
//         for (let i = 0; i < q.length; i++) {
//             if(q[i] !== (i+1)) {
//                 let indexDifference = q.indexOf(i+1) - i
//                 let element = q.splice(q.indexOf(i+1), 1)
//                 let rightOf = q.splice(i, q.length)
//                 q.push(...element)
//                 q.push(...rightOf)
//                 swaps += indexDifference
//             }
//         }
//         console.log(swaps)
//    } 
   
//    minimumBribes([5, 1, 2, 3, 7, 8, 6, 4])
    

        // Minimum Swaps 2 https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays
        
        // function minimumSwaps(arr) {
        //     let i = 0
        //     let swapped = 0

        //     arr.forEach((element, index) => {
        //         if(element-1 !== index) {
        //             let indexOfWanted = arr.indexOf(index + 1)
        //             arr[indexOfWanted] = element
        //             arr[index] = index + 1
        //             swapped += 1
        //         }
        //     })
        //     console.log(swapped)
        // }
        // minimumSwaps([4, 3, 1, 2])

        // function minimumSwaps(arr) {
        //     let swapped = 0
        //     for (let i = 0; i < arr.length; i++) {
        //         while(arr[i] !== (i+1)) {
        //             let temp = arr[arr[i] - 1] 
        //             arr[arr[i]-1] = arr[i]
        //             arr[i] = temp
        //             swapped += 1
        //             //console.log(arr)
        //         }
        //     }

        //     console.log(swapped)
        // }

        // function minimumSwapsSlower(arr) {
        //     let i = 0
        //     let swapped = 0
        //     for (i = 0; i < arr.length; i++) {
        //         while(arr[i] !== (i+1)) {
        //             let temp = arr[arr[i] - 1] 
        //             arr[arr[i]-1] = arr[i]
        //             arr[i] = temp
        //             swapped += 1
        //             //console.log(arr)
        //         }
        //     }

        //     console.log(swapped)
        // }

        // function randomizedArray(N) {
        //     let array = [...Array(N).keys()]
        //     array = array.map(e => e+1)
        //     let unsorted = array.sort((a, b) => {
        //         return (Math.ceil(Math.random() * N)-b) - (Math.ceil(Math.random() * N)-b)
        //     })
        //     return unsorted
        // }
        // let testArray = randomizedArray(10000)

        // console.time("first")
        // minimumSwaps(testArray)
        // console.timeEnd("first")
        
        // testArray = randomizedArray(10000)
        
        // console.time("second")
        // minimumSwapsSlower(testArray)
        // console.timeEnd("second")

        // ARRAY MANIPULATION - BRUTE FORCE https://www.hackerrank.com/challenges/crush/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays
        
        // function arrayManipulation(n, q) {
        //     // q[[a, b, k], [a2, b2, k2]...]
        //     // n - number of elements in starting array
        //     let array = [...Array(n).values()]
        //     array = array.map(e => 0)
        //     for(let i = 0; i < q.length; i++) {
        //         for(let j = (q[i][0]-1); j < q[i][1]; j++) {
        //             array[j] += q[i][2]
        //         }
        //     }
        //     console.log(Math.max(...array))
        // }
        // arrayManipulation(10, [[1, 5, 3], [4, 8, 7], [6, 9, 1]])
        
        // ARRAY MANIPULATION - SMART SOLUTION (Runtime error)

        // function arrayManipulation(n, q) {
        //     let array = []

        //     for (let i = 0; i < n+1; i++) {
        //         array.push(0)
        //     }
            
        //     for(let i = 0; i < q.length; i++) {
        //         array[q[i][0] - 1] += q[i][2]
        //         array[q[i][1]] !== undefined && (array[q[i][1]] += -(q[i][2]))
        //     }
            
        //     for (let i = 0; i < array.length; i++) {
        //        if(array[i-1] !== undefined) {
        //            array[i] += array[i-1]
        //        }
        //     }
        //     console.log(array)
        //     console.log(Math.max(...array))
        // }
        // arrayManipulation(10, [[1, 5, 3], [4, 8, 7], [6, 9, 1]])

        // ARRAY MANIPULATION - SMART SOLUTION (Without runtime error)
        // function arrayManipulation(n, q) {
        //     let array = []
        //     let result = 0
        //     for (let i = 0; i < n+1; i++) {
        //         array.push(0)
        //     }
            
        //     for(let i = 0; i < q.length; i++) {
        //         array[q[i][0] - 1] += q[i][2]
        //         array[q[i][1]] !== undefined && (array[q[i][1]] += -(q[i][2]))
        //     }

        //     array.reduce((cur, next) => {
        //         let res = cur + next
        //         if (res > result) {s
        //             result = res
        //         } 
        //         console.log(res)
        //         return res
        //     })
        //     console.log(array)
        //     return result
        // }

        // console.log(arrayManipulation(10, [[1, 5, 3], [4, 8, 7], [6, 9, 1]]))
        // arrayManipulation(40, [[29, 40, 787], 
        //                        [9, 26, 219], 
        //                        [21, 31, 214],
        //                        [8, 22, 719],
        //                        [15, 23, 102],
        //                        [11, 24, 83], 
        //                        [14, 22, 321],
        //                        [5, 22, 300],
        //                        [11, 30, 832], 
        //                        [5, 25, 29], 
        //                        [16, 24, 577],
        //                        [3, 10, 905],
        //                        [15, 22, 335],
        //                        [29, 35, 254],
        //                        [9, 20, 20],
        //                        [33, 34, 351],
        //                        [30, 38, 564],
        //                        [11, 31, 969],
        //                        [3, 32, 11],
        //                        [29, 35, 267],
        //                         [4, 24, 531],
        //                         [1, 38, 892],
        //                         [12, 18, 825],
        //                         [25, 32, 99],
        //                         [3, 39, 107],
        //                         [12, 37, 131],
        //                         [3, 26, 640],
        //                         [8, 39, 483],
        //                         [8, 11, 194],
        //                         [12, 37, 502]
        //                        ])
        /*


        1. Napiši funkcijju koja uzima niz objekata (objects) i ređa objekte prema dadotom property unazad.
        Ulaz: order(objects, property)
        Primer:
        Ulaz: order([{id: 3}, {id: 1}, {id: 4}, {id: 2}], "id")
        Izlaz: [{id: 1}, {id: 2}, {id: 3}, {id: 4}]

        */
            // function order(objects, property) {
            //     let values = []
            //     let result = []
            //     if(objects[0] !== undefined ) {
            //         // take values out of objects and sort them first
            //         let sortedValues = undefined
            //         for (let i = 0; i < objects.length; i++) {
            //             values.push(objects[i][property])
            //         }
            //         if(typeof objects[0][property] === "number") {
            //             sortedValues = values.sort((a, b) => a -b)
            //         } else if (typeof objects[0][property] === "string") {
            //             sortedValues = values.sort()
            //         } else return null
            //         console.log(sortedValues)
                    
            //         for (i = 0; i < sortedValues.length; i++) {
            //             result.push(objects.find(e => e[property] === sortedValues[i]))
            //         }
            //         console.log(result)
            //     }
            // }
            // order([{id: 3}, {id: 1}, {id: 4}, {id: 2}], "id")
            // order([{id: "Nemanja"}, {id: "Radmila"}, {id: "Andrijana"}, {id: "Miloš"}], "id")
       /*
        2. 

        Napiši funkciju koja pretražuje jednostavnu mrežu.
        Svaki čvor na mreži ima Id i pokazuje na sledeći čvor.
        Treba pronaći Id poslednjeg čvora do kog se može doći jedinstvenom putanjom 
        počveši od zadatog početnog čvora
        Veze između čvorova su prikazane preko fromIds i toIds nizova koji su povezani.
        Ako se desi da dođe do loop-a 
        Primer (nije dat ali je morao da se zaključi iz output-a na silu) 
        Primer: path(startingId, fromIds, toIds)
        Ulaz: path(6, [4, 9, 6, 1], [9, 5, 1, 4)
        Izlaz: 5
        */
    </script>
</body>
</html>